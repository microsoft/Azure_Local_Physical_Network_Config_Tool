#!/usr/bin/env node
/**
 * Template Bundler Script
 * 
 * Converts backend Jinja2 (.j2) templates into a TypeScript module
 * that can be imported by the frontend for client-side rendering.
 * 
 * Usage: node scripts/bundle-templates.js
 * Output: src/templates.ts
 */

const fs = require('fs');
const path = require('path');

const BACKEND_TEMPLATES_DIR = path.resolve(__dirname, '../../backend/templates');
const OUTPUT_FILE = path.resolve(__dirname, '../src/templates.ts');

/**
 * Recursively find all .j2 files in a directory
 */
function findTemplates(dir, basePath = '') {
  const templates = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relativePath = path.join(basePath, entry.name);
    
    if (entry.isDirectory()) {
      templates.push(...findTemplates(fullPath, relativePath));
    } else if (entry.name.endsWith('.j2')) {
      templates.push({
        path: relativePath.replace(/\\/g, '/'), // Normalize to forward slashes
        fullPath: fullPath
      });
    }
  }
  
  return templates;
}

/**
 * Escape template content for use in a JavaScript string
 */
function escapeForJS(content) {
  return content
    .replace(/\\/g, '\\\\')  // Escape backslashes first
    .replace(/`/g, '\\`')    // Escape backticks
    .replace(/\$\{/g, '\\${'); // Escape template literals
}

/**
 * Generate the TypeScript module
 */
function generateModule(templates) {
  const entries = templates.map(t => {
    const content = fs.readFileSync(t.fullPath, 'utf-8');
    const escaped = escapeForJS(content);
    return `  '${t.path}': \`${escaped}\``;
  });

  return `/**
 * Bundled Jinja2 Templates
 * 
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 * Generated by: scripts/bundle-templates.js
 * Source: backend/templates/
 * 
 * This file contains all Jinja2 templates as JavaScript strings
 * for client-side rendering with Nunjucks.
 */

export const TEMPLATES: Record<string, string> = {
${entries.join(',\n')}
};

/**
 * Get a template by its path (e.g., 'dellemc/os10/full_config.j2')
 */
export function getTemplate(templatePath: string): string {
  const template = TEMPLATES[templatePath];
  if (!template) {
    throw new Error(\`Template not found: \${templatePath}\`);
  }
  return template;
}

/**
 * Get all available template paths
 */
export function getTemplatePaths(): string[] {
  return Object.keys(TEMPLATES);
}

/**
 * Check if a template exists
 */
export function hasTemplate(templatePath: string): boolean {
  return templatePath in TEMPLATES;
}

/**
 * Get template paths for a specific vendor/firmware
 */
export function getVendorTemplates(vendor: string, firmware: string): string[] {
  const prefix = \`\${vendor}/\${firmware}/\`;
  return Object.keys(TEMPLATES).filter(p => p.startsWith(prefix));
}
`;
}

// Main execution
console.log('Bundling templates from:', BACKEND_TEMPLATES_DIR);

const templates = findTemplates(BACKEND_TEMPLATES_DIR);
console.log(`Found ${templates.length} templates:`);
templates.forEach(t => console.log(`  - ${t.path}`));

const moduleContent = generateModule(templates);
fs.writeFileSync(OUTPUT_FILE, moduleContent);

console.log(`\nGenerated: ${OUTPUT_FILE}`);
console.log('Done!');
