name: Triage Config Submissions

# Auto-validate and assign config submissions to Copilot
# Human only needs to review final PR before merge

on:
  issues:
    types: [opened, edited]

permissions:
  issues: write

jobs:
  validate-and-assign:
    # Only run for config submissions
    if: contains(github.event.issue.labels.*.name, 'config-submission')
    runs-on: ubuntu-latest
    
    steps:
      - name: Validate submission
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || '';
            const errors = [];
            const warnings = [];
            
            console.log('=== Validating Config Submission ===');
            console.log(`Issue #${context.issue.number}`);
            
            // ========================================
            // CHECK 1: Config has minimum content
            // ========================================
            const configSection = body.includes('### Switch Configuration') 
              ? body.split('### Switch Configuration')[1]?.split('###')[0] || ''
              : '';
            const configLines = configSection.trim().split('\n').filter(l => l.trim()).length;
            
            console.log(`Config lines found: ${configLines}`);
            
            if (configLines < 10) {
              errors.push('‚ùå Config appears too short (< 10 lines). Please provide full running config.');
            } else if (configLines < 30) {
              warnings.push('‚ö†Ô∏è Config is relatively short. Make sure you included the full running config.');
            }
            
            // ========================================
            // CHECK 2: Has switch-like patterns
            // ========================================
            const switchPatterns = [
              { pattern: /hostname\s+\S+/i, name: 'hostname' },
              { pattern: /interface\s+(ethernet|vlan|port-channel|loopback)/i, name: 'interface' },
              { pattern: /vlan\s+\d+/i, name: 'vlan' },
              { pattern: /ip\s+address/i, name: 'ip address' },
            ];
            
            const foundPatterns = switchPatterns.filter(p => p.pattern.test(body));
            console.log(`Switch patterns found: ${foundPatterns.map(p => p.name).join(', ')}`);
            
            if (foundPatterns.length === 0) {
              if (body.toLowerCase().includes('attached') || body.toLowerCase().includes('see file')) {
                warnings.push('‚ö†Ô∏è Config appears to be in an attached file. Maintainer will verify.');
              } else {
                errors.push('‚ùå Config missing typical switch patterns (hostname, interface, vlan, etc.)');
              }
            }
            
            // ========================================
            // CHECK 3: No obvious spam/injection
            // ========================================
            const spamPatterns = [
              /<script/i,
              /javascript:/i,
              /onclick=/i,
              /onerror=/i,
            ];
            const templatePatterns = [
              /\$\{.*\}/,
              /\{\{.*\}\}/,
            ];
            
            const hasSpam = spamPatterns.some(p => p.test(body));
            if (hasSpam) {
              errors.push('‚ùå Submission contains suspicious patterns. Please remove any scripts or code injection attempts.');
            }
            const hasTemplatePatterns = templatePatterns.some(p => p.test(body));
            if (hasTemplatePatterns) {
              warnings.push('‚ö†Ô∏è Config contains template-like patterns (${ } or {{ }}). This is fine for Dell OS10 / Jinja2 configs.');
            }
            
            // ========================================
            // CHECK 4: Required checkboxes completed
            // ========================================
            const checkedBoxes = (body.match(/- \[x\]/gi) || []).length;
            const totalBoxes = (body.match(/- \[[ x]\]/gi) || []).length;
            
            console.log(`Checkboxes: ${checkedBoxes}/${totalBoxes} checked`);
            
            if (checkedBoxes < 2) {
              errors.push('‚ùå Please check the required checkboxes (sanitization and CONTRIBUTING.md review).');
            }
            
            // ========================================
            // CHECK 5: Required fields present
            // ========================================
            const requiredFields = [
              { name: 'Submission Type', pattern: /### What do you need\?\s*\n\s*\S+/i },
              { name: 'Deployment Pattern', pattern: /### Deployment Pattern\s*\n\s*\S+/i },
              { name: 'Switch Vendor', pattern: /### Switch Vendor\s*\n\s*\S+/i },
              { name: 'Firmware/OS', pattern: /### Firmware\/OS Version\s*\n\s*\S+/i },
              { name: 'Switch Model', pattern: /### Switch Model\s*\n\s*\S+/i },
              { name: 'Switch Role', pattern: /### Switch Role\s*\n\s*\S+/i },
            ];
            
            const missingFields = requiredFields.filter(f => !f.pattern.test(body));
            if (missingFields.length > 0) {
              errors.push(`‚ùå Missing required fields: ${missingFields.map(f => f.name).join(', ')}`);
            }
            
            // ========================================
            // CHECK 6: Submission type specific checks
            // ========================================
            const submissionTypeSection = body.includes('### What do you need?')
              ? body.split('### What do you need?')[1]?.split('###')[0]?.trim() || ''
              : '';
            const isFix = /fix\s*\/\s*improvement/i.test(submissionTypeSection);
            const isNewVendor = /new\s*vendor\s*\/\s*model/i.test(submissionTypeSection);
            
            console.log(`Submission type: ${isFix ? 'Fix/Improvement' : isNewVendor ? 'New Vendor/Model' : 'Unknown'}`);
            
            // For Fix submissions, "What's wrong?" is important (warn if empty, don't block)
            if (isFix) {
              const whatsWrongSection = body.includes("### What's wrong or what needs to change?")
                ? body.split("### What's wrong or what needs to change?")[1]?.split('###')[0]?.trim() || ''
                : '';
              if (whatsWrongSection.length < 10) {
                warnings.push('‚ö†Ô∏è **"What\'s wrong?"** field is empty or very short. Please describe the issue so Copilot knows where to look. Examples: "HSRP priority should be 200", "Missing BGP neighbor for spine"');
              }
            }
            
            // ========================================
            // CHECK 7: Credential scan (basic)
            // ========================================
            const credentialPatterns = [
              /password\s+\S+/i,
              /enable\s+secret\s+\S+/i,
              /snmp-server\s+community\s+\S+/i,
              /BEGIN.*PRIVATE\s+KEY/i,
              /tacacs-server.*key\s+\S+/i,
              /radius-server.*key\s+\S+/i,
            ];
            // Exclude lines with placeholder patterns
            const configWithoutPlaceholders = configSection.replace(/\$CREDENTIAL_PLACEHOLDER\$/gi, '');
            const foundCredentials = credentialPatterns.filter(p => p.test(configWithoutPlaceholders));
            
            if (foundCredentials.length > 0) {
              errors.push('‚ùå **Possible credentials detected** in your config. Please replace all passwords, secrets, and keys with `$CREDENTIAL_PLACEHOLDER$` and re-submit.');
            }
            
            // ========================================
            // CHECK 8: Lab JSON validation (if provided)
            // ========================================
            const labJsonSection = body.includes('### Lab JSON Input')
              ? body.split('### Lab JSON Input')[1]?.split('###')[0]?.trim() || ''
              : '';
            if (labJsonSection.length > 20) {
              // Strip markdown code fences if present
              const jsonText = labJsonSection.replace(/^```[\w]*\n?/m, '').replace(/\n?```$/m, '').trim();
              try {
                const parsed = JSON.parse(jsonText);
                if (!parsed.InputData && !parsed.Version) {
                  warnings.push('‚ö†Ô∏è Lab JSON provided but missing expected keys (`Version`, `InputData`). Copilot will validate further.');
                }
              } catch (e) {
                warnings.push('‚ö†Ô∏è Lab JSON provided but has syntax errors. Copilot will attempt to fix or ask for clarification.');
              }
            }
            
            // ========================================
            // RESULT
            // ========================================
            const result = {
              valid: errors.length === 0,
              errors,
              warnings,
              configLines,
              patternsFound: foundPatterns.map(p => p.name),
              submissionType: isFix ? 'fix' : isNewVendor ? 'new_vendor' : 'unknown',
            };
            
            console.log('Validation result:', JSON.stringify(result, null, 2));
            core.setOutput('result', JSON.stringify(result));
            return result;

      - name: Handle valid submission - Assign to Copilot
        if: fromJson(steps.validate.outputs.result).valid
        uses: actions/github-script@v7
        env:
          VALIDATION_RESULT: ${{ steps.validate.outputs.result }}
        with:
          script: |
            const result = JSON.parse(process.env.VALIDATION_RESULT);
            const warnings = result.warnings || [];
            const submissionType = result.submissionType || 'unknown';
            
            console.log(`‚úÖ Submission validated (type: ${submissionType}), assigning to Copilot`);
            
            // Remove triage labels
            const labelsToRemove = ['needs-triage', 'needs-info'];
            for (const label of labelsToRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: label
                });
              } catch (e) {
                // Label might not exist, ignore
              }
            }
            
            // Add Copilot assignment labels
            const labels = ['copilot', 'validated'];
            if (submissionType === 'new_vendor') {
              labels.push('new-vendor');
            }
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: labels
            });
            
            // Build comment
            const typeLabel = submissionType === 'fix'
              ? '**Fix / Improvement** ‚Äî Copilot will analyze your config, identify the affected templates or code, and create a targeted fix PR.'
              : submissionType === 'new_vendor'
              ? '**New Vendor / Model** ‚Äî Copilot will analyze your config and create scaffold templates, switch interface definitions, and a reference archive.'
              : '**Config Submission** ‚Äî Copilot will analyze your config and create a PR.';
            
            let comment = '## ‚úÖ Submission Validated\n\n';
            comment += `Submission type: ${typeLabel}\n\n`;
            
            if (warnings.length > 0) {
              comment += '### Warnings\n';
              comment += warnings.join('\n') + '\n\n';
            }
            
            comment += '### What happens next?\n';
            comment += '1. ü§ñ **Copilot** analyzes your config and creates a PR\n';
            comment += '2. üë§ **Maintainer** reviews the PR\n';
            comment += '3. ‚úÖ **Merge** ‚Äî your contribution improves the tool for everyone\n\n';
            comment += '> **Reminder:** This repo provides reference configurations only. ';
            comment += 'You are responsible for validating in your environment.\n';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

      - name: Handle invalid submission - Request fixes
        if: "!fromJson(steps.validate.outputs.result).valid"
        uses: actions/github-script@v7
        env:
          VALIDATION_RESULT: ${{ steps.validate.outputs.result }}
        with:
          script: |
            const result = JSON.parse(process.env.VALIDATION_RESULT);
            const errors = result.errors || [];
            const warnings = result.warnings || [];
            
            console.log('‚ùå Submission needs fixes');
            
            // Add needs-info label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['needs-info']
            });
            
            // Remove copilot label if present
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'copilot'
              });
            } catch (e) {}
            
            // Build comment
            let comment = '## ‚ö†Ô∏è Submission Needs Attention\n\n';
            comment += 'Please address the following before Copilot can process your submission:\n\n';
            comment += '### Issues Found\n';
            comment += errors.join('\n') + '\n\n';
            
            if (warnings.length > 0) {
              comment += '### Warnings\n';
              comment += warnings.join('\n') + '\n\n';
            }
            
            comment += '### How to fix\n';
            comment += '1. Click **Edit** on this issue\n';
            comment += '2. Fix the issues listed above\n';
            comment += '3. Save ‚Äî the validation will run again automatically\n\n';
            comment += 'If you believe this is an error, a maintainer will review manually.\n';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
